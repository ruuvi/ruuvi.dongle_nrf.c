
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ruuvi_driver_sensor.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#ifndef RUUVI_DRIVER_SENSOR_H</a>
<a name="ln2">#define RUUVI_DRIVER_SENSOR_H</a>
<a name="ln3">/**</a>
<a name="ln4"> * @defgroup Sensor Common sensor interface</a>
<a name="ln5"> * @brief Functions for setting up and using sensors</a>
<a name="ln6"> *</a>
<a name="ln7"> *</a>
<a name="ln8"> */</a>
<a name="ln9">/** @{ */</a>
<a name="ln10">/**</a>
<a name="ln11"> * @file ruuvi_driver_sensor.h</a>
<a name="ln12"> * @author Otso Jousimaa &lt;otso@ojousima.net&gt;</a>
<a name="ln13"> * @date 2020-06-01</a>
<a name="ln14"> * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause</a>
<a name="ln15"> * @brief Ruuvi sensor interface &lt;b&gt;Lifecycle: Beta&lt;/b&gt;</a>
<a name="ln16"> *</a>
<a name="ln17"> *</a>
<a name="ln18"> *</a>
<a name="ln19"> * Common interface to all Ruuvi Sensors</a>
<a name="ln20"> * Every sensor must implement these functions:</a>
<a name="ln21"> * - init</a>
<a name="ln22"> * - uninit</a>
<a name="ln23"> * - samplerate_set</a>
<a name="ln24"> * - samplerate_get</a>
<a name="ln25"> * - dsp_set</a>
<a name="ln26"> * - dsp_get</a>
<a name="ln27"> * - scale_set</a>
<a name="ln28"> * - scale_set</a>
<a name="ln29"> * - resolution_set</a>
<a name="ln30"> * - resolution_get</a>
<a name="ln31"> * - mode_set</a>
<a name="ln32"> * - mode_get</a>
<a name="ln33"> * - data_get</a>
<a name="ln34"> *</a>
<a name="ln35"> * If function does not make sense for the sensor, it will return error code.</a>
<a name="ln36"> *</a>
<a name="ln37"> * Return name: Return a pointer to a constant 8-byte long string which represensts sensor, e.g. LIS2DH12\0 or BME280\0\0</a>
<a name="ln38"> *</a>
<a name="ln39"> * INIT, UNINT: Init will prepare sensor for use, reset the sensor, run self-test and place it in low-power mode. Additionally function pointers will be set up by init.</a>
<a name="ln40"> *              Uninit will release any resources used by sensor</a>
<a name="ln41"> *</a>
<a name="ln42"> * Samplerate: Applicable on continuous mode, how often sensor takes samples. Hz</a>
<a name="ln43"> *</a>
<a name="ln44"> * DSP: DSP function and parameter, i.e. &quot;OVERSAMPLING, 16&quot;. Return error if the device does not support it.</a>
<a name="ln45"> *</a>
<a name="ln46"> * scale: Maximum scale in a meaningful physical unit, such as celcius or pascal.</a>
<a name="ln47"> *</a>
<a name="ln48"> * resolution: Resolution in bits.</a>
<a name="ln49"> *</a>
<a name="ln50"> * mode: Sleep, single, continuous.</a>
<a name="ln51"> *  - Sleep mode should enter lowest-power state available</a>
<a name="ln52"> *  - Single will return once new data is available with data_get call</a>
<a name="ln53"> *  - Continuous: Sensor will sample at given rate. Returns immediately, data will be available after first sample</a>
<a name="ln54"> *</a>
<a name="ln55"> * data get: return latest sample from sensor</a>
<a name="ln56"> */</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;ruuvi_driver_error.h&quot;</a>
<a name="ln59">#include &lt;stdbool.h&gt;</a>
<a name="ln60">#include &lt;stddef.h&gt;</a>
<a name="ln61">#include &lt;stdint.h&gt;</a>
<a name="ln62"> </a>
<a name="ln63">#define RD_SENSOR_INVALID_VALUE    RD_FLOAT_INVALID  //!&lt; Signal this sensor value is erroneous</a>
<a name="ln64">#define RD_SENSOR_INVALID_TIMSTAMP RD_UINT64_INVALID //!&lt; Signal this timestamp value is erroneous</a>
<a name="ln65"> </a>
<a name="ln66">// Constants for sensor configuration and status</a>
<a name="ln67">#define RD_SENSOR_CFG_DEFAULT         (0U)      //!&lt; Default value, always valid for the sensor.</a>
<a name="ln68">#define RD_SENSOR_CFG_CUSTOM_1        (0xC9U)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln69">#define RD_SENSOR_CFG_CUSTOM_2        (0xCAU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln70">#define RD_SENSOR_CFG_CUSTOM_3        (0xCBU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln71">#define RD_SENSOR_CFG_CUSTOM_4        (0xCCU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln72">#define RD_SENSOR_CFG_CUSTOM_5        (0xCDU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln73">#define RD_SENSOR_CFG_CUSTOM_6        (0xCEU)   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln74">#define RD_SENSOR_ERR_INVALID         (0xE0U)   //!&lt; Error code, given parameter is invalid</a>
<a name="ln75">#define RD_SENSOR_ERR_NOT_IMPLEMENTED (0xE1U)   //!&lt; Error code, given parameter is not implemented (todo)</a>
<a name="ln76">#define RD_SENSOR_ERR_NOT_SUPPORTED   (0xE2U)   //!&lt; Error code, given parameter is not supported by sensor</a>
<a name="ln77">#define RD_SENSOR_CFG_MIN             (0xF0U)   //!&lt; Configure smallest supported and implemented value</a>
<a name="ln78">#define RD_SENSOR_CFG_MAX             (0xF1U)   //!&lt; Configure largest supported and implemented value</a>
<a name="ln79">#define RD_SENSOR_CFG_SLEEP           (0xF2U)   //!&lt; Sensor should go to sleep immediately</a>
<a name="ln80">#define RD_SENSOR_CFG_SINGLE          (0xF3U)   //!&lt; Sensor should go to sleep after single measurement</a>
<a name="ln81">#define RD_SENSOR_CFG_CONTINUOUS      (0xF4U)   //!&lt; Sensor will keep sampling at defined sample rate</a>
<a name="ln82">#define RD_SENSOR_CFG_NO_CHANGE       (0xFFU)   //!&lt; Do not change configured value</a>
<a name="ln83"> </a>
<a name="ln84">// DSP functions, complemented by DSP parameter</a>
<a name="ln85">#define RD_SENSOR_DSP_LAST            (0U)    //!&lt; Return last value from sensor. Parameter: No effect. Use default</a>
<a name="ln86">#define RD_SENSOR_DSP_LOW_PASS        (1U&lt;&lt;1U) //!&lt; Low pass sensor values Parameter: coefficient</a>
<a name="ln87">#define RD_SENSOR_DSP_HIGH_PASS       (1U&lt;&lt;2U) //!&lt; High pass sensor values Parameter: coefficient</a>
<a name="ln88">#define RD_SENSOR_DSP_OS              (1U&lt;&lt;3U) //!&lt; Oversample sensor values. Parameter: Number of samples</a>
<a name="ln89"> </a>
<a name="ln90">/** @brief convert Ruuvi GPIO into uint8_t */</a>
<a name="ln91">#define RD_GPIO_TO_HANDLE(handle) ((((handle) &gt;&gt; 3U) &amp; 0xE0U) + ((handle) &amp; 0x1FU))</a>
<a name="ln92">/** @brief convert uint8_t into Ruuvi GPIO */</a>
<a name="ln93">#define RD_HANDLE_TO_GPIO(handle) ((((handle) &amp; 0xE0U) &lt;&lt; 3U) + ((handle) &amp; 0x1FU))</a>
<a name="ln94">/** @brief Mark sensor as unused with this handle */</a>
<a name="ln95">#define RD_HANDLE_UNUSED (0xFFU)</a>
<a name="ln96"> </a>
<a name="ln97">/**</a>
<a name="ln98"> * @brief All sensors must implement configuration functions which accept this struct.</a>
<a name="ln99"> */</a>
<a name="ln100">typedef struct __attribute__ ( (packed, aligned (4)))</a>
<a name="ln101">{</a>
<a name="ln102">    uint8_t samplerate;     //!&lt; Samplerate, in Hz</a>
<a name="ln103">    uint8_t resolution;     //!&lt; Resolution, in bits</a>
<a name="ln104">    uint8_t scale;          //!&lt; Scale, in relevant Si-unit</a>
<a name="ln105">    uint8_t dsp_function;   //!&lt; DSP function, one of @c RD_SENSOR_DSP_*</a>
<a name="ln106">    uint8_t dsp_parameter;  //!&lt; Parameter to DSP functions</a>
<a name="ln107">    uint8_t mode;           //!&lt; Mode, RD_SENSOR_SLEEP, _SINGLE, _CONTINOUS</a>
<a name="ln108">    uint8_t reserved0;      //!&lt; Reserved for future use</a>
<a name="ln109">    uint8_t reserved1;      //!&lt; Reserved for future use</a>
<a name="ln110">}</a>
<a name="ln111">rd_sensor_configuration_t;</a>
<a name="ln112"> </a>
<a name="ln113">/**</a>
<a name="ln114"> * @brief Type of bus sensor uses.</a>
<a name="ln115"> */</a>
<a name="ln116">typedef enum</a>
<a name="ln117">{</a>
<a name="ln118">    RD_BUS_NONE = 0U, //!&lt; No bus, internal to IC</a>
<a name="ln119">    RD_BUS_SPI  = 1U, //!&lt; SPI bus</a>
<a name="ln120">    RD_BUS_I2C  = 2U, //!&lt; I2C bus</a>
<a name="ln121">    RD_BUS_UART = 3U, //!&lt; UART bus</a>
<a name="ln122">    RD_BUS_PDM  = 4U, //!&lt; PDM bus</a>
<a name="ln123">    RD_BUS_FAIL = 5U  //!&lt; Test behaviour on invalid bus with this value.</a>
<a name="ln124">} rd_bus_t;</a>
<a name="ln125"> </a>
<a name="ln126">/**</a>
<a name="ln127"> * @brief Bitfield to describe related sensor data</a>
<a name="ln128"> */</a>
<a name="ln129">typedef struct</a>
<a name="ln130">{</a>
<a name="ln131">    unsigned int acceleration_x_g : 1; //!&lt; Acceleration along X-axis, gravities.</a>
<a name="ln132">    unsigned int acceleration_y_g : 1; //!&lt; Acceleration along Y-axis, gravities.</a>
<a name="ln133">    unsigned int acceleration_z_g : 1; //!&lt; Acceleration along Z-axis, gravities.</a>
<a name="ln134">    unsigned int co2_ppm : 1;          //!&lt; CO2, Parts per million.</a>
<a name="ln135">    unsigned int gyro_x_dps : 1;       //!&lt; Rotation along X-axis, degrees per second.</a>
<a name="ln136">    unsigned int gyro_y_dps : 1;       //!&lt; Rotation along Y-axis, degrees per second.</a>
<a name="ln137">    unsigned int gyro_z_dps : 1;       //!&lt; Rotation along Z-axis, degrees per second.</a>
<a name="ln138">    unsigned int humidity_rh : 1;      //!&lt; Relative humidity, %.</a>
<a name="ln139">    /** @brief Light level, dimensionless. Comparable only between identical devices. */</a>
<a name="ln140">    unsigned int luminosity  : 1;</a>
<a name="ln141">    unsigned int magnetometer_x_g : 1; //!&lt; Magnetic flux along X-axis, Gauss.</a>
<a name="ln142">    unsigned int magnetometer_y_g : 1; //!&lt; Magnetic flux along Y-axis, Gauss.</a>
<a name="ln143">    unsigned int magnetometer_z_g : 1; //!&lt; Magnetic flux along Z-axis, Gauss.</a>
<a name="ln144">    unsigned int pm_1_ugm3 : 1;        //!&lt; Ultra-fine particulate matter, microgram per m^3.</a>
<a name="ln145">    unsigned int pm_2_ugm3 : 1;        //!&lt; Fine particulate matter, microgram per m^3.</a>
<a name="ln146">    unsigned int pm_4_ugm3 : 1;        //!&lt; Medium particulate matter, microgram per m^3.</a>
<a name="ln147">    unsigned int pm_10_ugm3 : 1;       //!&lt; Coarse particulate matter, microgram per m^3.</a>
<a name="ln148">    unsigned int pressure_pa : 1;      //!&lt; Pressure, pascals</a>
<a name="ln149">    unsigned int spl_dbz : 1;          //!&lt; Unweighted sound pressure level.</a>
<a name="ln150">    unsigned int temperature_c : 1;    //!&lt; Temperature, celcius</a>
<a name="ln151">    unsigned int voc_ppm : 1;          //!&lt; Volatile organic compounds, parts per million.</a>
<a name="ln152">    unsigned int voltage_v : 1;        //!&lt; Voltage, volts.</a>
<a name="ln153">    unsigned int voltage_ratio : 1;    //!&lt; Voltage, ratio to maximum</a>
<a name="ln154">    unsigned int reserved: 10;         //!&lt; Reserved bits, force remainder of bitfield to 0.</a>
<a name="ln155">} rd_sensor_data_bitfield_t;</a>
<a name="ln156"> </a>
<a name="ln157">/**</a>
<a name="ln158"> * C99 Standard 6.7.8.21</a>
<a name="ln159"> * If there are fewer initializers in a brace-enclosed list than there are</a>
<a name="ln160"> * elements or members of an aggregate, or fewer characters in a string literal</a>
<a name="ln161"> * used to initialize an array of known size than there are elements in the array,</a>
<a name="ln162"> * the remainder of the aggregate shall be initialized implicitly the same as</a>
<a name="ln163"> * objects that have static storage duration.</a>
<a name="ln164"> */</a>
<a name="ln165">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln166">#define RD_SENSOR_ACC_X_FIELD ((rd_sensor_data_fields_t){.datas.acceleration_x_g=1})</a>
<a name="ln167">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln168">#define RD_SENSOR_ACC_Y_FIELD ((rd_sensor_data_fields_t){.datas.acceleration_y_g=1})</a>
<a name="ln169">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln170">#define RD_SENSOR_ACC_Z_FIELD ((rd_sensor_data_fields_t){.datas.acceleration_z_g=1})</a>
<a name="ln171">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln172">#define RD_SENSOR_GYR_X_FIELD ((rd_sensor_data_fields_t){.datas.gyro_x_dps=1})</a>
<a name="ln173">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln174">#define RD_SENSOR_GYR_Y_FIELD ((rd_sensor_data_fields_t){.datas.gyro_y_dps=1})</a>
<a name="ln175">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln176">#define RD_SENSOR_GYR_Z_FIELD ((rd_sensor_data_fields_t){.datas.gyro_z_dps=1})</a>
<a name="ln177">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln178">#define RD_SENSOR_HUMI_FIELD ((rd_sensor_data_fields_t){.datas.humidity_rh=1})</a>
<a name="ln179">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln180">#define RD_SENSOR_PRES_FIELD ((rd_sensor_data_fields_t){.datas.pressure_pa=1})</a>
<a name="ln181">/** @brief Shorthand for calling rd_sensor_data_parse(p_data, FIELD) */</a>
<a name="ln182">#define RD_SENSOR_TEMP_FIELD ((rd_sensor_data_fields_t){.datas.temperature_c=1})</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185"> </a>
<a name="ln186">/**</a>
<a name="ln187"> * @brief Union to access sensor data.</a>
<a name="ln188"> *</a>
<a name="ln189"> * MISRA deviation: Use of union.</a>
<a name="ln190"> * Union is used here for fast operations on sensor data through field bitfield</a>
<a name="ln191"> * and to give a meaningful value to each bit through datas.</a>
<a name="ln192"> *</a>
<a name="ln193"> * C99 and onwards allow type punning, but this is not portable to C++.</a>
<a name="ln194"> * Run the integration tests on your platform.</a>
<a name="ln195"> *</a>
<a name="ln196"> */</a>
<a name="ln197">typedef union // -V2514</a>
<a name="ln198">{</a>
<a name="ln199">    uint32_t bitfield; //!&lt; Bitfield used to access sensor data.</a>
<a name="ln200">    rd_sensor_data_bitfield_t datas; //!&lt; Structured data field.</a>
<a name="ln201">} rd_sensor_data_fields_t;</a>
<a name="ln202"> </a>
<a name="ln203">/**</a>
<a name="ln204"> * @brief Generic sensor data struct.</a>
<a name="ln205"> *</a>
<a name="ln206"> * The data sensor struct contains a timestamp relative to sensor boot,</a>
<a name="ln207"> * a list of fields contained within the sensor data and a pointer to array</a>
<a name="ln208"> * of floats which contain the actual data.</a>
<a name="ln209"> */</a>
<a name="ln210">typedef struct rd_sensor_data_t</a>
<a name="ln211">{</a>
<a name="ln212">    uint64_t timestamp_ms;      //!&lt; Timestamp of the event, @ref rd_sensor_timestamp_get.</a>
<a name="ln213">    rd_sensor_data_fields_t</a>
<a name="ln214">    fields; //!&lt; Description of datafields which may be contained in this sample.</a>
<a name="ln215">    rd_sensor_data_fields_t valid;  //!&lt; Listing of valid data in this sample.</a>
<a name="ln216">    /** @brief Data of sensor. Must contain as many elements as fields has bits set. */</a>
<a name="ln217">    float * data;</a>
<a name="ln218">} rd_sensor_data_t;</a>
<a name="ln219"> </a>
<a name="ln220">/** @brief Forward declare type definition of sensor structure */</a>
<a name="ln221">typedef struct rd_sensor_t rd_sensor_t;</a>
<a name="ln222"> </a>
<a name="ln223">/**</a>
<a name="ln224"> * @brief Initialize and uninitialize sensor.</a>
<a name="ln225"> * Init and uninit will setup sensor with function pointers.</a>
<a name="ln226"> * The sensor wil be initialized to lowest power state possible.</a>
<a name="ln227"> *</a>
<a name="ln228"> * @param[in,out] p_sensor pointer to sensor structure</a>
<a name="ln229"> * @param[in] bus bus to use, i.r. I2C or SPI</a>
<a name="ln230"> * @param[in] handle for the sensor, for example I2C address or SPI chip select pin</a>
<a name="ln231"> * @return @c RD_SUCCESS on success</a>
<a name="ln232"> * @return @c RD_ERROR_NULL if p_sensor is NULL</a>
<a name="ln233"> * @return @c RD_ERROR_NOT_FOUND if there is no response from sensor or if ID of</a>
<a name="ln234"> *            a sensor read over bus does not match expected value</a>
<a name="ln235"> * @return @c RD_ERROR_SELFTEST if sensor is found but it does not pass selftest</a>
<a name="ln236"> * @return @c RD_ERROR_INVALID_STATE if trying to initialize sensor which</a>
<a name="ln237"> *            already has been initialized.</a>
<a name="ln238"> **/</a>
<a name="ln239">typedef rd_status_t (*rd_sensor_init_fp) (rd_sensor_t * const</a>
<a name="ln240">        p_sensor, const rd_bus_t bus, const uint8_t handle);</a>
<a name="ln241"> </a>
<a name="ln242">/**</a>
<a name="ln243"> *  @brief Setup a parameter of a sensor.</a>
<a name="ln244"> *  The function will modify the pointed data to the actual value which was written</a>
<a name="ln245"> *</a>
<a name="ln246"> *  @param[in,out] parameter value to write to sensor configuration. Actual value written to sensor as output</a>
<a name="ln247"> *  @return RD_SUCCESS on success</a>
<a name="ln248"> *  @return RD_ERROR_NULL if parameter is NULL</a>
<a name="ln249"> *  @return RD_ERROR_NOT_SUPPORTED if sensor cannot support given parameter</a>
<a name="ln250"> *  @return RD_ERROR_NOT_IMPLEMENTED if the sensor could support parameter, but it's not implemented in fw.</a>
<a name="ln251"> **/</a>
<a name="ln252">typedef rd_status_t (*rd_sensor_setup_fp) (uint8_t * parameter);</a>
<a name="ln253"> </a>
<a name="ln254">/**</a>
<a name="ln255"> * @brief Configure sensor digital signal processing.</a>
<a name="ln256"> * Takes DSP function and a DSP parameter as input, configured value or error code as output.</a>
<a name="ln257"> * Modifies input parameters to actual values written on the sensor.</a>
<a name="ln258"> * DSP functions are run on the sensor HW, not in the platform FW.</a>
<a name="ln259"> *</a>
<a name="ln260"> * @param[in,out] dsp_function. DSP function to run on sensor. Can be a combination of several functions.</a>
<a name="ln261"> * @param[in,out] dsp_parameter. Parameter to DSP function(s)</a>
<a name="ln262"> * @return RD_SUCCESS on success</a>
<a name="ln263"> * @return RD_ERROR_NULL if either parameter is NULL</a>
<a name="ln264"> * @return RD_ERROR_NOT_SUPPORTED if sensor doesn't support given DSP</a>
<a name="ln265"> * @return RD_ERROR_NOT_IMPLEMENTED if sensor supports given DSP, but</a>
<a name="ln266"> *         driver does not implement it</a>
<a name="ln267"> * @return RD_ERROR_INVALID_PARAM if parameter is invalid for any reason.</a>
<a name="ln268"> **/</a>
<a name="ln269">typedef rd_status_t (*rd_sensor_dsp_fp) (uint8_t * dsp_function,</a>
<a name="ln270">        uint8_t * dsp_parameter);</a>
<a name="ln271"> </a>
<a name="ln272">/**</a>
<a name="ln273"> * @brief Read latest data from sensor registers</a>
<a name="ln274"> * Return latest data from sensor. Does not take a new sample, calling this function twice</a>
<a name="ln275"> * in a row returns same data. Configure sensor in a single-shot mode to take a new sample</a>
<a name="ln276"> * or leave sensor in a continuous mode to get updated data.</a>
<a name="ln277"> *</a>
<a name="ln278"> * p_data may contain, some, none or all of fields sensor is able to provide.</a>
<a name="ln279"> * Fields which are already marked as valid will not be overwritten, filled fields</a>
<a name="ln280"> * will get marked as valid.</a>
<a name="ln281"> *</a>
<a name="ln282"> * @param [out] p_data Pointer to sensor data @ref rd_sensor_data_t .</a>
<a name="ln283"> * @return RD_SUCCESS on success</a>
<a name="ln284"> * @return RD_ERROR_NULL if p_data is @c NULL.</a>
<a name="ln285"> *</a>
<a name="ln286"> */</a>
<a name="ln287">typedef rd_status_t (*rd_sensor_data_fp) (rd_sensor_data_t * const p_data);</a>
<a name="ln288"> </a>
<a name="ln289">/**</a>
<a name="ln290"> * @brief Convenience function to write/read entire configuration in one call.</a>
<a name="ln291"> * Modifies input parameters to actual values written on the sensor.</a>
<a name="ln292"> *</a>
<a name="ln293"> * @param[in] p_sensor sensor to configure</a>
<a name="ln294"> * @param[in,out] p_configuration Input: desired configuration. Output:</a>
<a name="ln295"> *                configuration written to sensot.</a>
<a name="ln296"> * @retval RD_SUCCESS if sensor was configured successfully.</a>
<a name="ln297"> * @retval RD_ERROR_NULL if one of parameters is NULL</a>
<a name="ln298"> * @return Error code from driver on other error.</a>
<a name="ln299"> **/</a>
<a name="ln300">typedef rd_status_t (*rd_configuration_fp) (</a>
<a name="ln301">    const rd_sensor_t * const p_sensor,</a>
<a name="ln302">    rd_sensor_configuration_t * const p_configuration);</a>
<a name="ln303"> </a>
<a name="ln304">/**</a>
<a name="ln305">* @brief Read First-in-first-out (FIFO) buffer in sensor.</a>
<a name="ln306">* Reads up to num_elements data points from FIFO and populates pointer data with them.</a>
<a name="ln307">*</a>
<a name="ln308">* @param[in, out] num_elements Input: number of elements in data.</a>
<a name="ln309">                               Output: Number of elements placed in data.</a>
<a name="ln310">* @param[out] Data array of  with num_elements slots.</a>
<a name="ln311">* @retval RD_SUCCESS on success.</a>
<a name="ln312">* @retval RD_ERROR_NULL if either parameter is NULL.</a>
<a name="ln313">* @retval RD_ERROR_INVALID_STATE if FIFO is not in use.</a>
<a name="ln314">* @retval RD_ERROR_NOT_SUPPORTED if the sensor does not have FIFO.</a>
<a name="ln315">* @return error code from stack on error.</a>
<a name="ln316">*/</a>
<a name="ln317">typedef rd_status_t (*rd_sensor_fifo_read_fp) (size_t * const num_elements,</a>
<a name="ln318">        rd_sensor_data_t * const data);</a>
<a name="ln319"> </a>
<a name="ln320">/**</a>
<a name="ln321">* @brief Enable FIFO or FIFO interrupt full interrupt on sensor.</a>
<a name="ln322">* FIFO interrupt Triggers an interrupt once FIFO is filled.</a>
<a name="ln323">* It is responsibility of application to know the routing of and polarity of GPIO pins and</a>
<a name="ln324">* configure the GPIO to register interrupts.</a>
<a name="ln325">*</a>
<a name="ln326">* @param[in] enable True to enable interrupt, false to disable interrupt</a>
<a name="ln327">* @return RD_SUCCESS on success, error code from stack otherwise.</a>
<a name="ln328">**/</a>
<a name="ln329">typedef rd_status_t (*rd_sensor_fifo_enable_fp) (const bool enable);</a>
<a name="ln330"> </a>
<a name="ln331">/**</a>
<a name="ln332">* @brief Enable level interrupt on sensor.</a>
<a name="ln333">*</a>
<a name="ln334">* Triggers as ACTIVE HIGH interrupt while detected data is above threshold.</a>
<a name="ln335">*</a>
<a name="ln336">* Trigger is symmetric, i.e. threshold is valid for above positive or below negative</a>
<a name="ln337">* of given value.</a>
<a name="ln338">*</a>
<a name="ln339">* On accelerometer data is high-passed to filter out gravity.</a>
<a name="ln340">* Axes are examined individually, compound data won't trigger the interrupt. e.g.</a>
<a name="ln341">* accelerometer showing 0.8 G along X, Y, Z axes won't trigger at threshold of 1 G,</a>
<a name="ln342">* even though the vector sum of axes is larger than 1 G.</a>
<a name="ln343">*</a>
<a name="ln344">* It is responsibility of application to know the GPIO routing and register</a>
<a name="ln345">* GPIO interrupts.</a>
<a name="ln346">*</a>
<a name="ln347">* @param[in] enable  True to enable interrupt, false to disable interrupt</a>
<a name="ln348">* @param[in,out] limit_g: Input: Desired acceleration to trigger the interrupt.</a>
<a name="ln349">*                         Is considered as &quot;at least&quot;, the acceleration is rounded up to</a>
<a name="ln350">*                         next value.</a>
<a name="ln351">*                         Output: written with value that was set to interrupt</a>
<a name="ln352">* @retval RD_SUCCESS on success.</a>
<a name="ln353">* @retval RD_INVALID_STATE if data limit is higher than maximum scale.</a>
<a name="ln354">* @return error code from stack on error.</a>
<a name="ln355">*</a>
<a name="ln356">*/</a>
<a name="ln357">typedef rd_status_t (*rd_sensor_level_interrupt_use_fp) (const bool enable,</a>
<a name="ln358">        float * limit_g);</a>
<a name="ln359"> </a>
<a name="ln360">/**</a>
<a name="ln361"> * @brief Return number of milliseconds since the start of RTC.</a>
<a name="ln362"> *</a>
<a name="ln363"> * @return milliseconds since start of RTC.</a>
<a name="ln364"> * @return RD_UINT64T_INVALID if RTC is not running</a>
<a name="ln365"> */</a>
<a name="ln366">typedef uint64_t (*rd_sensor_timestamp_fp) (void);</a>
<a name="ln367"> </a>
<a name="ln368">/**</a>
<a name="ln369"> * @brief Interface to sensor.</a>
<a name="ln370"> * Some sensors can implement additional functions.</a>
<a name="ln371"> * The additional functions are defined in the interface of the sensor.</a>
<a name="ln372"> */</a>
<a name="ln373">typedef struct rd_sensor_t</a>
<a name="ln374">{</a>
<a name="ln375">    /** @brief Sensor human-readable name. Should be at most 8 bytes long. */</a>
<a name="ln376">    const char * name;</a>
<a name="ln377">    /** @brief handle for sensor internal context */</a>
<a name="ln378">    void * p_ctx;</a>
<a name="ln379">    /** @brief Description of data fields the sensor is able to provide. */</a>
<a name="ln380">    rd_sensor_data_fields_t provides;</a>
<a name="ln381">    /** @brief @ref rd_sensor_init_fp */</a>
<a name="ln382">    rd_sensor_init_fp  init;</a>
<a name="ln383">    /** @brief @ref rd_sensor_init_fp */</a>
<a name="ln384">    rd_sensor_init_fp  uninit;</a>
<a name="ln385">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln386">    rd_sensor_setup_fp samplerate_set;</a>
<a name="ln387">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln388">    rd_sensor_setup_fp samplerate_get;</a>
<a name="ln389">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln390">    rd_sensor_setup_fp resolution_set;</a>
<a name="ln391">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln392">    rd_sensor_setup_fp resolution_get;</a>
<a name="ln393">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln394">    rd_sensor_setup_fp scale_set;</a>
<a name="ln395">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln396">    rd_sensor_setup_fp scale_get;</a>
<a name="ln397">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln398">    rd_sensor_setup_fp mode_set;</a>
<a name="ln399">    /** @brief @ref rd_sensor_setup_fp */</a>
<a name="ln400">    rd_sensor_setup_fp mode_get;</a>
<a name="ln401">    /** @brief @ref rd_sensor_dsp_fp */</a>
<a name="ln402">    rd_sensor_dsp_fp   dsp_set;</a>
<a name="ln403">    /** @brief @ref rd_sensor_dsp_fp */</a>
<a name="ln404">    rd_sensor_dsp_fp   dsp_get;</a>
<a name="ln405">    /** @brief @ref rd_configuration_fp */</a>
<a name="ln406">    rd_configuration_fp configuration_set;</a>
<a name="ln407">    /** @brief @ref rd_configuration_fp */</a>
<a name="ln408">    rd_configuration_fp configuration_get;</a>
<a name="ln409">    /** @brief @ref rd_sensor_data_fp */</a>
<a name="ln410">    rd_sensor_data_fp   data_get;</a>
<a name="ln411">    /** @brief @®ef rd_sensor_fifo_enable_fp */</a>
<a name="ln412">    rd_sensor_fifo_enable_fp fifo_enable;</a>
<a name="ln413">    /** @brief @®ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln414">    rd_sensor_fifo_enable_fp fifo_interrupt_enable;</a>
<a name="ln415">    /** @brief @®ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln416">    rd_sensor_fifo_read_fp   fifo_read;</a>
<a name="ln417">    /** @brief @®ef rd_sensor_level_interrupt_use_fp */</a>
<a name="ln418">    rd_sensor_level_interrupt_use_fp level_interrupt_set;</a>
<a name="ln419">} rd_sensor_t;</a>
<a name="ln420"> </a>
<a name="ln421">/**</a>
<a name="ln422"> * @brief Implementation of ref rd_configuration_fp</a>
<a name="ln423"> */</a>
<a name="ln424">rd_status_t rd_sensor_configuration_set (const rd_sensor_t *</a>
<a name="ln425">        sensor, rd_sensor_configuration_t * config);</a>
<a name="ln426"> </a>
<a name="ln427">/**</a>
<a name="ln428"> * @brief Implementation of ref rd_configuration_fp</a>
<a name="ln429"> */</a>
<a name="ln430">rd_status_t rd_sensor_configuration_get (const rd_sensor_t *</a>
<a name="ln431">        sensor, rd_sensor_configuration_t * config);</a>
<a name="ln432"> </a>
<a name="ln433">/**</a>
<a name="ln434"> * @brief Setup timestamping.</a>
<a name="ln435"> * Set to @c NULL to disable timestamps.</a>
<a name="ln436"> *</a>
<a name="ln437"> * @param[in] timestamp_fp Function pointer to @ref rd_sensor_timestamp_fp implementation</a>
<a name="ln438"> * @retval RD_SUCCESS.</a>
<a name="ln439"> */</a>
<a name="ln440">rd_status_t rd_sensor_timestamp_function_set (</a>
<a name="ln441">    const rd_sensor_timestamp_fp  timestamp_fp);</a>
<a name="ln442"> </a>
<a name="ln443">/**</a>
<a name="ln444"> * @brief Calls the timestamp function and returns its value.</a>
<a name="ln445"> * @return milliseconds since the start of RTC.</a>
<a name="ln446"> * @retval RD_UINT64_INVALID if timestamp function is NULL</a>
<a name="ln447"> */</a>
<a name="ln448">uint64_t rd_sensor_timestamp_get (void);</a>
<a name="ln449"> </a>
<a name="ln450">/**</a>
<a name="ln451"> * @brief Initialize sensor struct with non-null pointers which</a>
<a name="ln452"> *        return RD_ERROR_NOT_INITIALIZED.</a>
<a name="ln453"> *</a>
<a name="ln454"> * This function is to ensure that NULL function pointers won't be called.</a>
<a name="ln455"> * If name was NULL before calling this, name will point to &quot;NOTINIT&quot;.</a>
<a name="ln456"> * If name was already set, it won't be changed.</a>
<a name="ln457"> *</a>
<a name="ln458"> * @param[out] p_sensor pointer to sensor struct to initialize.</a>
<a name="ln459"> */</a>
<a name="ln460">void rd_sensor_initialize (rd_sensor_t * const p_sensor);</a>
<a name="ln461"> </a>
<a name="ln462">/**</a>
<a name="ln463"> * @brief Mark sensor as uninitialized by calling the generic initialization.</a>
<a name="ln464"> * Will not clear the name of the sensor.</a>
<a name="ln465"> *</a>
<a name="ln466"> * @param[out] p_sensor pointer to sensor struct to uninitialize.</a>
<a name="ln467"> */</a>
<a name="ln468">void rd_sensor_uninitialize (rd_sensor_t * const p_sensor);</a>
<a name="ln469"> </a>
<a name="ln470">/**</a>
<a name="ln471"> * @brief Check if given sensor structure is already initialized.</a>
<a name="ln472"> *</a>
<a name="ln473"> * @param[in] sensor Sensor interface to check.</a>
<a name="ln474"> * @return true if structure is initialized, false otherwise.</a>
<a name="ln475"> */</a>
<a name="ln476">bool rd_sensor_is_init (const rd_sensor_t * const sensor);</a>
<a name="ln477"> </a>
<a name="ln478">/**</a>
<a name="ln479"> * @brief Populate given target data with data provided by sensor as requested.</a>
<a name="ln480"> *</a>
<a name="ln481"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln482"> * and populates it with provided data if caller requested the field to be populated.</a>
<a name="ln483"> * Populated fields are marked as valid.</a>
<a name="ln484"> *</a>
<a name="ln485"> * Example: Board can have these sensors in this order of priority:</a>
<a name="ln486"> *  - TMP117 (temperature)</a>
<a name="ln487"> *  - SHTC3 (temperature, humidity)</a>
<a name="ln488"> *  - DPS310 (temperature, pressure)</a>
<a name="ln489"> *  - LIS2DH12 (acceleration, temperature)</a>
<a name="ln490"> *</a>
<a name="ln491"> * If a target with fields for temperature, humidity, pressure and acceleration is</a>
<a name="ln492"> * created and populated from data of the sensors end result will be:</a>
<a name="ln493"> *</a>
<a name="ln494"> * -&gt; Temperature, timestamp from TMP117</a>
<a name="ln495"> * -&gt; Humidity from SHTC3</a>
<a name="ln496"> * -&gt; Pressure from DPS310</a>
<a name="ln497"> * -&gt; Acceleration from LIS2DH12</a>
<a name="ln498"> *</a>
<a name="ln499"> * If same firmware is run on a board with only LIS2DH12 populated, end result will be</a>
<a name="ln500"> *</a>
<a name="ln501"> * -&gt; Temperature, timestamp, acceleration from LIS2DH12</a>
<a name="ln502"> * -&gt; RD_FLOAT_INVALID on humidity and pressure.</a>
<a name="ln503"> *</a>
<a name="ln504"> * @param[out] target Data to be populated. Fields must be initially populated with</a>
<a name="ln505"> *                    RD_FLOAT_INVALID.</a>
<a name="ln506"> * @param[in]  provided Data provided by sensor.</a>
<a name="ln507"> * @param[in]  requested Fields to be filled if possible.</a>
<a name="ln508"> */</a>
<a name="ln509">void rd_sensor_data_populate (rd_sensor_data_t * const target,</a>
<a name="ln510">                              const rd_sensor_data_t * const provided,</a>
<a name="ln511">                              const rd_sensor_data_fields_t requested);</a>
<a name="ln512"> </a>
<a name="ln513">/**</a>
<a name="ln514"> * @brief Parse data from provided struct.</a>
<a name="ln515"> *</a>
<a name="ln516"> * @param[in]  provided Data to be parsed.</a>
<a name="ln517"> * @param[in]  requested One data field to be parsed.</a>
<a name="ln518"> * @return     sensor value if found, RD_FLOAT_INVALID if the provided data didn't</a>
<a name="ln519"> *             have a valid value.</a>
<a name="ln520"> */</a>
<a name="ln521">float rd_sensor_data_parse (const rd_sensor_data_t * const provided,</a>
<a name="ln522">                            const rd_sensor_data_fields_t requested);</a>
<a name="ln523"> </a>
<a name="ln524">/**</a>
<a name="ln525"> * @brief Count number of floats required for this data structure.</a>
<a name="ln526"> *</a>
<a name="ln527"> * @param[in]  target Structure to count number of fields from.</a>
<a name="ln528"> * @return     Number of floats required to store the sensor data.</a>
<a name="ln529"> */</a>
<a name="ln530">uint8_t rd_sensor_data_fieldcount (const rd_sensor_data_t * const target);</a>
<a name="ln531"> </a>
<a name="ln532">/**</a>
<a name="ln533"> * @brief Set a desired value to target data.</a>
<a name="ln534"> *</a>
<a name="ln535"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln536"> * and populates it with provided data. Does nothing if there is no appropriate slot</a>
<a name="ln537"> * in target data.</a>
<a name="ln538"> *</a>
<a name="ln539"> * This is a shorthand for @ref rd_sensor_data_populate for only one data field, without</a>
<a name="ln540"> * setting timestamp.</a>
<a name="ln541"> *</a>
<a name="ln542"> * @param[out] target</a>
<a name="ln543"> * @param[in]  field  Quantity to set, exactly one must be set to true.</a>
<a name="ln544"> * @param[in]  value  Value of quantity,</a>
<a name="ln545"> */</a>
<a name="ln546">void rd_sensor_data_set (rd_sensor_data_t * const target,</a>
<a name="ln547">                         const rd_sensor_data_fields_t field,</a>
<a name="ln548">                         const float value);</a>
<a name="ln549"> </a>
<a name="ln550">/**</a>
<a name="ln551"> * @brief Validate that given setting can be set on a sensor which supports only default value.</a>
<a name="ln552"> *</a>
<a name="ln553"> * @param[in,out] input Input: Must be RD_SENSOR_CFG_DEFAULT, _NO_CHANGE, _MIN or _MAX.</a>
<a name="ln554"> *                      Output: _DEFAULT</a>
<a name="ln555"> * @param[in] mode Mode sensor is currently in. Must be sleep to configure sensor.</a>
<a name="ln556"> */</a>
<a name="ln557">rd_status_t validate_default_input_set (uint8_t * const input, const uint8_t mode);</a>
<a name="ln558"> </a>
<a name="ln559">/**</a>
<a name="ln560"> * @brief Validate and get input when only allowed value is default.</a>
<a name="ln561"> *</a>
<a name="ln562"> * @param[out] input Setting of sensor to get. Will be RD_SENSOR_CFG_DEFAULT.</a>
<a name="ln563"> *</a>
<a name="ln564"> * @retval RD_SUCCESS if input is not NULL.</a>
<a name="ln565"> * @retval RD_ERROR_NULL if input is NULL.</a>
<a name="ln566"> */</a>
<a name="ln567">rd_status_t validate_default_input_get (uint8_t * const input);</a>
<a name="ln568"> </a>
<a name="ln569">/**</a>
<a name="ln570"> * @brief Check if sensor has valid data at given index.</a>
<a name="ln571"> *</a>
<a name="ln572"> * Data is considered valid if target-&gt;fields and target-&gt;valid both are set.</a>
<a name="ln573"> * Index is referred to number of fields.</a>
<a name="ln574"> *</a>
<a name="ln575"> * Typical usage:</a>
<a name="ln576"> * @code</a>
<a name="ln577"> * const uint8_t fieldcount = rd_sensor_data_fieldcount(p_data);</a>
<a name="ln578"> * for(uint8_t ii = 0; ii &lt; fieldcount; ii++)</a>
<a name="ln579"> * {</a>
<a name="ln580"> *     if(rd_sensor_has_valid_data(p_data, ii)</a>
<a name="ln581"> *     {</a>
<a name="ln582"> *        do_stuff(p_data-&gt;data[ii], rd_sensor_field_type(p_data, ii));</a>
<a name="ln583"> *     }</a>
<a name="ln584"> * }</a>
<a name="ln585"> * @endcode</a>
<a name="ln586"> *</a>
<a name="ln587"> * @param[in] target Pointer to data to check.</a>
<a name="ln588"> * @param[in] index index of data to check.</a>
<a name="ln589"> * @retval true If data at target-&gt;data[index] has a valid value.</a>
<a name="ln590"> * @retval false If target is NULL, index is higher than fields in data or data at</a>
<a name="ln591"> *               index is not marked as valid.</a>
<a name="ln592"> *</a>
<a name="ln593"> * @note To determine the type of data, use @ref rd_sensor_field_type.</a>
<a name="ln594"> */</a>
<a name="ln595">bool rd_sensor_has_valid_data (const rd_sensor_data_t * const target,</a>
<a name="ln596">                               const uint8_t index);</a>
<a name="ln597"> </a>
<a name="ln598">/**</a>
<a name="ln599"> * @brief Check the type of data at given index.</a>
<a name="ln600"> *</a>
<a name="ln601"> * This function is used to determine what type of data given index has.</a>
<a name="ln602"> *</a>
<a name="ln603"> * Typical usage:</a>
<a name="ln604"> * @code</a>
<a name="ln605"> * rd_sensor_data_bitfield_t type = rd_sensor_field_type(p_data, index);</a>
<a name="ln606"> * if(1 == type.temperature_c)</a>
<a name="ln607"> * {</a>
<a name="ln608"> *    do_stuff_with_temperature (p_data-&gt;data[index])</a>
<a name="ln609"> * }</a>
<a name="ln610"> * @endcode</a>
<a name="ln611"> *</a>
<a name="ln612"> * @param[in] target Data to check</a>
<a name="ln613"> * @param[in] index  Index of field to check.</a>
<a name="ln614"> * @return rd_sensor_data_bitfield_t with field corresponding to index set, or 0 if</a>
<a name="ln615"> *                                   target doesn't have any data type at given index.</a>
<a name="ln616"> */</a>
<a name="ln617">rd_sensor_data_bitfield_t rd_sensor_field_type (const rd_sensor_data_t * const target,</a>
<a name="ln618">        const uint8_t index);</a>
<a name="ln619"> </a>
<a name="ln620">/** @} */</a>
<a name="ln621">#endif</a>

</code></pre>
<div class="balloon" rel="119"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '1U' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>
<div class="balloon" rel="120"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '2U' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>
<div class="balloon" rel="121"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '3U' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>
<div class="balloon" rel="122"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '4U' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>
<div class="balloon" rel="123"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '5U' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
